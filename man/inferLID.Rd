% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inferLID.R
\name{inferLID}
\alias{inferLID}
\title{Infer if dispersion is significant}
\usage{
inferLID(
  lid,
  w,
  ntrials = 999,
  alpha = 0.05,
  standard = NULL,
  expect = NULL,
  var.stand = FALSE,
  var.exp = FALSE,
  ng.invert = TRUE,
  max.cross = .Machine$integer.max,
  pb = TRUE,
  clear.mem = FALSE
)
}
\arguments{
\item{lid}{The list output from the \code{\link[lbmech]{LID}} function.}

\item{w}{The same spatial weights matrix used in calculating the \code{lid} input.}

\item{ntrials}{The number of permutations to perform. Default is 999.}

\item{alpha}{Threshold for significance. Default is \code{alpha = 0.05}.}

\item{standard}{The standards matrix with dimensions \code{length(x) x length(x)} used 
when calculating \code{lid}. Ignored if none had been originally provided, otherwise
required.}

\item{expect}{The expectations matrix with dimensions \code{length(x) x length(x)} used 
when calculating \code{lid}. Ignored if none had been originally provided, otherwise
required.}

\item{var.stand}{Logical. Should the standards be permuted if a matrix was 
provided? Default is \code{FALSE}.}

\item{var.exp}{Logical. Should the expectations be permuted if a matrix was
provided? Default is \code{FALSE}.}

\item{ng.invert}{Does a higher non-group value imply higher between group inequality?
Default is \code{TRUE}. This is ignored if matrixes were not originally provided, as 
it is automatically performed.}

\item{max.cross}{When processing, what is the maximum number of rows that 
an internal data.table can have? This is generally not a concern unless
the number of observations approaches \code{sqrt(.Machine$integer.max)}--usually
about 2^31 for most systems. Lower values result in a greater number of chunks
thus allowing larger data.sets to be calculated.}

\item{pb}{Logical. Should a progress bar be displayed? Default is \code{FALSE}, although
if a large dataset is processed that requires adjusting \code{max.cross} this can
be useful}

\item{clear.mem}{Logical. Should \code{\link[base]{gc}} be run in the middle of the 
calculation? Default is \code{clear.mem} but set as \code{TRUE} if memory limits are a concern.}
}
\value{
A list with the following entries:

(1) \code{$local} A data.table with one column, indicating whether an observation is
falls in one of nine categories: Out-group High, Average, or Low for between-group
inequality, and In-group High, Average, or Low for within-group inequality based on
the significance according to the delta-J statistic in the \code{$stats} data.table. 

(2) \code{$global} A list with four entries, \code{$J_G} for the group component of the 
global inequality, \code{$J_NG} for the nongroup, \code{$J} for the total,
and $Class, containing the significance class for the global dataset. Each 
of the first three entries themselves contain three entriesL
\code{$delta}, representing the delta-J statistic, \code{$p}, representing its p-value,
and $Class, containing the group/non-group class

(3) \code{$stats} A data.table containing the number of permutations a randomly-calculated
\code{$J_Gi}, \code{$J_NGi}, or \code{$J_i} was above or below the real value
}
\description{
Infer whether there exists more or less within- and between-group
local and global inequality than would be expected versus if for all observations
the values of all other observations were permuted. This tests if local values
are significantly above or below what is expected given the global dataset, and
if global values are significantly above or below what is expected given an 
otherwise random distribution.
}
\details{
The output list can be passed to \code{\link[lbmech]{scatterLID}} to plot
the group and non-group components of local inequality based on the significance
classes.
}
\examples{

# Generate dummy observations
x <- runif(10, 1, 100)

# Get distance matrix
dists <- dist(x)

# Get fuzzy weights considering 5 nearest neighbors based on 
# inverse square distance
weights <- makeWeights(dists, bw = 5, 
                       mode = 'adaptive', weighting = 'distance',
                       FUN = function(x) 1/x^2, minval = 0.1,
                       row.stand = 'fuzzy')
                       
# Obtain the 'local gini' value
lid <- LID(x, w = weights, index = 'gini', type = 'local')

# Infer whether values are significant relative to the spatial distribution
# of the neighbots
inference <- inferLID(lid, w = weights, ntrials = 100)
}
