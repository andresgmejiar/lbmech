% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/makeGrid.R
\name{makeGrid}
\alias{makeGrid}
\title{Make partitioning grid}
\usage{
makeGrid(
  dem,
  nx,
  ny,
  path = NA,
  sources = FALSE,
  extension = NULL,
  proj = NULL,
  prefix = "SECTOR_",
  crop = TRUE,
  zoom = 13,
  var = "z",
  overlap = 0.005
)
}
\arguments{
\item{dem}{One of either a single character string, SpatVector (polygon),
SpatialPolygons*, SpatRaster, or Raster


If character, SpatRaster, Raster, such an object or (filepath to one) 
containing the elevations for the maximum possible extent imaginable for a study. 
Note that SpatRaster and Raster only work
rasters that have been read in, not those that exist exclusively in the memory. 
If you  have just generated the raster and it is in memory, export it first with
\code{\link[terra]{writeRaster}} then use the filepath string as \code{dem} or
re-import it with \code{\link[terra]{rast}} before using the SoatRaster object.

If SpatVector or SpatialPolygons*, the extent of possible movement.}

\item{nx}{The integer-number of columns in the output grid}

\item{ny}{The integer-number of rows in the output grid}

\item{path}{(Optional) The filepath or URL of the source DEM. Ignored if 
\code{dem} is of class raster or SpatRaster. If a SpatVector or SpatialPolygons
is provided but no path, \code{\link[lbmech]{getMap}} will use
\code{\link[elevatr]{get_elev_raster}} to download topographic data.}

\item{sources}{Logical. Should source information be saved as attributes
to the grid for use in \code{\link[lbmech]{getMap}} and 
\code{\link[lbmech]{defineWorld}}? Default is \code{sources = FALSE}.}

\item{extension}{A character vector representing the extension of the source
path. Required only if \code{sources = TRUE} and the extension is not apparent
from the URL stored in the \code{var} column.}

\item{proj}{A \code{\link[terra]{crs}} or something coercible to it representing 
the desired output projection. Default is the input raster's projection.}

\item{prefix}{A character string containing the prefix to name individual sectors.
Default is \code{prefix = "SECTOR_"}}

\item{crop}{Logical. If TRUE (the default), the output polygons will be cropped
by the original \code{dem} (if SpatVector or SpatialPolygons*), or by
the area covered by non-NA cells (if raster or SpatRaster).}

\item{zoom}{Considered only if \code{var = 'z'} and no data source is set. 
The zoom level to be downloaded. 
Default is 13, but see documentation for the \code{z} parameter in 
\code{\link[elevatr]{get_elev_raster}}.}

\item{var}{If the polygons point to a data source, what will be the variable
name in the internal GIS? Default is 'z' for elevation.}

\item{overlap}{How much should adjacent polygons overlap to ensure there's
contiguity between different tiles? Default is \code{overlap = 0.005}.}
}
\value{
Polygons of class SpatVector representing the individual sectors ('tiles'),
with a dataframe containing three columns: the "TILEID", the raster's filepath,
and a dummy column indicating that the grid was made using the makeGrid function.
This will be necessary for future functions. The object MUST be stored 
on the disk, it should not be stored in the memory
}
\description{
Generate a partitioning grid for a single raster source representing regional
elevations. Smaller partitioning grids (i.e. a greater value of \code{nx * ny})
results in a greater number of saved files and a greater number of
read-write operations in future operations, but reduces the amount of
memory employed.
}
\examples{
# Generate a DEM, export it
n <- 5
dem <- expand.grid(list(x = 1:(n * 100),
                        y = 1:(n * 100))) / 100
dem <- as.data.table(dem)
dem[, z := 250 * exp(-(x - n/2)^2) + 
      250 * exp(-(y - n/2)^2)]
dem <- rast(dem)
ext(dem) <- c(10000, 20000, 30000, 40000)
crs(dem) <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84"

dir <- tempdir()
writeRaster(dem, paste0(dir,"/DEM.tif"),overwrite=TRUE)


# Import raster, get the grid
dem <- rast(paste0(dir,"/DEM.tif"))
grid <- makeGrid(dem = dem, nx = n, ny = n, sources = TRUE)

}
