% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getVelocity.R
\name{getVelocity}
\alias{getVelocity}
\alias{dtVelocity}
\title{Calculate a velocity function from data}
\usage{
getVelocity(
  data,
  x = "x",
  y = "y",
  degs = FALSE,
  dl = NULL,
  z = "z",
  dt = "dt",
  ID = "ID",
  tau = NULL,
  tau_vmax = 0.95,
  tau_nlrq = 0.5,
  k_init = 3.5,
  s_init = -0.05,
  v_min = 0,
  v_lim = Inf,
  slope_lim = 1,
  tile_id = "TILEID",
  vals = "location",
  dir = tempdir(),
  ...
)

dtVelocity(data, ...)
}
\arguments{
\item{data}{A data.frame or something coercible to a data.table containing
all observations}

\item{x}{A character string representing the data column containing the 'x'
coordinates in meters or degrees. Ignored if data is of class SpatVector
or Spatial, and ignored for distance calculations if \code{dl} is
provided but required to extract elevations if \code{z} is of class
Raster* or SpatialPolygonsDataFrame.}

\item{y}{A character string representing the data column containing the 'y'
coordinates in meters or degrees. Ignored if data is of class SpatVector
or Spatial, and ignored for distance calculations if \code{dl} is
provided but required to extract elevations if \code{z} is of class SpatRaster,
Raster*, or SpatVector, SpatialPolygonsDataFrame.}

\item{degs}{Logical. If FALSE, the \code{getVelocity} proceeds as if the
input coordinates are meters in a projected coordinate system. If 
TRUE, assumes the input coordinates are decimal degrees in lat/long, with
\code{x} giving the longitude column name and \code{y} the latitude. See
\code{\link[geosphere]{distGeo}}.}

\item{dl}{A character string representing the data column containing the
net displacement between this observation and the previous in meters. Optional.}

\item{z}{Either a character string, a SpatRaster or Raster*, or a SpatVector
object. If character string, it represents the data column containing the 'z'
coordinates/elevations in meters. If a SpatRaster or Raster*, a DEM containing
the elevation in meters. If SpatVector, it must represent the
sectors and filepaths/URLs corresponding to the region's elevations
(see the output of \code{\link[lbmech]{makeGrid}}).}

\item{dt}{A character string representing the data column containing the
time difference from the previous observation in seconds.}

\item{ID}{A character string representing the data column containing the
unique ID for each observed trajectory. In other words, each set of points
for each continuous observation for each observed individual would merit a
unique id.}

\item{tau}{A number between 0 and 1, representing a global cutoff
value for \code{tau_vmax} and \code{tau_nlrq}. Ignored if the latter two are provided.}

\item{tau_vmax}{A number between 0 and 1, representing the percentile at which
the maximum velocity is calculated. In other words, if \code{tau_vmax = 0.95} (the default),
the maximum velocity will be at the 99.5th percentile of all observations.}

\item{tau_nlrq}{A number between 0 and 1, representing the percentile at which
the nonlinear regression is calculated. In other words, if \code{tau_nlrq = 0.50} (the default),
the total curve will attempt to have at each interval 5\% of the observations above the
regression and 95\% below.}

\item{k_init}{A number representing the value for the topographic sensitivity
at which to initiate the nonlinear regression. Default is \code{k_init = 3.5}.}

\item{s_init}{A number representing the value for dimensionless slope of
maximum velocity at which to initiate the nonlinear regression. Default is
\code{s_init = -0.05}.}

\item{v_min}{The maximum velocity that will be considered. Any value equal to or
below this will be excluded from the regression. Default is \code{v_lim = 0}.}

\item{v_lim}{The maximum velocity that will be considered. Any value above
this will be excluded from the regression. Default is \code{v_lim = Inf},
but it should be set to an animal's maximum possible velocity.}

\item{slope_lim}{the maximum angle that will be considered. Any value
above this will be excluded from the regression. Default is \code{slope_lim = 1}.}

\item{tile_id}{a character string representing the name of the column
in the \code{z} polygon containing the unique Tile IDs. Ignored if elevations are
provided as a column or Raster*. Otherwise default is \code{tile_id = 'TILEID'}.}

\item{vals}{A character string or a Raster* object. Required only if the
\code{z} parameter is a polygon NOT the output of the 
\code{\link[lbmech]{makeGrid}} function as the default is
the character string \code{'location'}. If not, the \code{vals} parameter should be
set to the column name containing the URL or file path to the DEM for that
sector.}

\item{dir}{A filepath to the directory being used as the workspace.
Default is \code{tempdir()} but unless the analyses will only be performed a few
times it is highly recommended to define a permanent workspace.}

\item{...}{Additional parameters to pass to \code{\link[lbmech]{importMap}}.
Ignored unless \code{z} is a polygon pointing to source dem files.}
}
\value{
A list, containing the following entries:

(1) \code{$model}, containing an object of class \code{\link[quantreg]{nlrq}} containing the output
model from the nonlinear quantitative regression.

(2) \code{$vmax}, containing the identified maximum velocity.

(3) \code{$s}, containing the identified angle of maximum velocity.

(4) \code{$k}, containing the identified topographic sensitivity factor.

(5) \code{$tau_max}, containing the employed tau_max.

(6) \code{$tau_nlrq}, containing the employed tau_nlrq.

(7) \code{$data}, containing a data.table with the original data in a standardized format
}
\description{
Calculate the velocity function for an animal from \emph{(x,y,z,t)} data
such as from GPS collars, assuming a function of form Tobler (see ####).
}
\details{
\code{dtVelocity} is a wrapper for \code{\link[lbmech]{getVelocity}} for use 
inside of a data.table with observations from multiple sources
(be it different individual animals and/or different instances
from the same animal). In a \code{\link[data.table]{data.table}},
use this function in the \code{j} slot, passing it along \code{.SD}.
}
\examples{
# Note that the output results should be senseless since they
# are computed on random data

#### Example 1:
# If the data contains an 'elevation' or 'z' column
data <- data.table(x = runif(10000,10000,20000),
                   y = runif(10000,30000,40000),
                   elevation = runif(10000,0,200),
                   dt = 120,
                   ID = rep(1:10,each=1000))
velocity <- getVelocity(data = data, z = 'elevation')


#### Example 2:
# If the data do not contain elevation, and 'z' is a raster
suppressWarnings( data[, z := NULL])

# Generate a DEM
n <- 5
dem <- expand.grid(list(x = 1:(n * 100),
                        y = 1:(n * 100))) / 100
dem <- as.data.table(dem)
dem[, z := 250 * exp(-(x - n/2)^2) + 
      250 * exp(-(y - n/2)^2)]
dem <- rast(dem)
ext(dem) <- c(10000, 20000, 30000, 40000)
crs(dem) <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84"

velocity <- getVelocity(data = data, z = dem)


### Example 3:
# If the data do not contain elevation, and 'z' is a sector grid pointing
# to file locations

# Export the DEM so it's not just stored on the memory
dir <- tempdir()
writeRaster(dem, paste0(dir,"/DEM.tif"),overwrite=TRUE)

# Import raster, get the grid
dem <- rast(paste0(dir,"/DEM.tif"))
grid <- makeGrid(dem = dem, nx = n, ny = n, sources = TRUE)

velocity <- getVelocity(data = data, z = grid, dir = dir, res = res(dem))

#' # Example 4:
# If you want to get the values by group within a data.table

# Generate fake data with x,y coordinates, z elevation, and a t
# column representing the number of seconds into the observation
data <- data.table(x = runif(10000,10000,20000),
                   y = runif(10000,30000,40000),
                   z = runif(10000,0,200),
                   dt = 15,
                   ID = rep(1:10,each=1000))
                   
# To get the velocity function for all observations together
v1 <- getVelocity(data)

# This is the same as above, but it only returns a list with the 
# coefficients and p-values
v2 <- dtVelocity(data)

# Instead this function is best to get the coefficients for 
# each individual track un a data.table using .SD
v3 <- data[, dtVelocity(.SD), by = 'ID', .SDcols = names(data)]
}
