% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getPaths.R
\name{getPaths}
\alias{getPaths}
\title{Get least-cost paths}
\usage{
getPaths(
  region,
  nodes,
  id = "ID",
  order = NULL,
  x = "x",
  y = "y",
  costs = "all",
  polygons = "centroid",
  dir = tempdir(),
  ...
)
}
\arguments{
\item{region}{A SpatVector, Spatial* or Raster* representing the area of 
maximum movement}

\item{nodes}{One of data.frame, data.table, SpatVector, SpatialPointsDataFrame, or
SpatialPolygonsDataFrame representing the node locations. 
If it is a polygon, the location will be controlled by the \code{polygons} parameter.}

\item{id}{A character string representing the column containing each \code{node}
location's unique ID.}

\item{order}{A character vector containing the desired path in
order of visited nodes by ID. Required if  For example, to visit "A" then "B" then "C" then "A"
the vector would be \code{c("A","B","C","A")}. If this is not provided, 
the function assumes that \code{nodes} is  already sorted in the desired order.}

\item{x}{A character vector representing the column containing the 'x' coordinates.
Required if \code{data} is not Spatial*.}

\item{y}{A character vector representing the column containing the 'y' coordinates.
Required if \code{data} is not Spatial*.}

\item{costs}{A character vector containing any combination of the strings
of differential values present in the environment (see 
\code{\link[lbmech]{calculateCosts}} function; default is 
\code{costs = c("dt","dW_l","dE_l")} anticipating the use of 
\code{\link[lbmech]{calculateCosts}(costFUN = \link[lbmech]{energyCosts})}.}

\item{polygons}{One of \code{c('polygon','centroid','center')}. Ignored unless
\code{nodes} are polygons. If \code{polygons = 'centroid'} (the default),
the destinations are calculated to the centroid of the polygon whether or not
it lies within the polygon itself. If \code{polygons = 'center'}, distances
are calculated to the point within the polygon closest to the centroid. If 
\code{polygons = 'polygons'}, distances are calculated to *any* point within the 
polygon---in essence, the polygon acts as a giant node permitting costless
movement within its bounds. This is generally not consistent with real-world
scenarios and for that reason is not the default.}

\item{dir}{A filepath to the directory being used as the workspace.
Default is \code{tempdir()} but unless the analyses will only be performed a few
times it is highly recommended to define a permanent workspace.}

\item{...}{Additional parameters to pass to \code{\link[lbmech]{importWorld}}.}
}
\value{
SpatialVector lines representing least-cost paths. For each
cost, each entry within the SpatialLinesDataFrame object represents
a single leg of the journey, sorted in the original path order.
If \code{length(costs) == 1}, only a SpatVector is returned.
If \code{length(costs) > 1}
a list of SpatVectors with one slot for each \code{cost} is returned.
}
\description{
Get the shortest path for a given trip that requires travel through a
set of nodes. Use is like \code{\link[lbmech]{getCosts}}, but with 
\code{nodes} and {order} parameters and no \code{from} or \code{to}.
}
\examples{
# Generate a DEM
n <- 5
dem <- expand.grid(list(x = 1:(n * 100),
                        y = 1:(n * 100))) / 100
dem <- as.data.table(dem)
dem[, z := 250 * exp(-(x - n/2)^2) + 
      250 * exp(-(y - n/2)^2)]
dem <- rast(dem)
ext(dem) <- c(10000, 20000, 30000, 40000)
crs(dem) <- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84"

# Export it so it doesn't just exist on the memory
dir <- tempdir()
writeRaster(dem, paste0(dir,"/DEM.tif"),overwrite=TRUE)


# Import raster, get the grid
dem <- rast(paste0(dir,"/DEM.tif"))
grid <- makeGrid(dem = dem, nx = n, ny = n, sources = TRUE)
region <- grid[8, ]

# Select all tiles that exist between x = (12000,16000) and y = (32000,36000)
tiles <- ext(c(12000,16000,32000,36000))
tiles <- as.polygons(tiles)
crs(tiles) <- crs(grid)
tiles <- whichTiles(region = tiles, polys = grid)

# Make a world but limit it to the DEM grid size
calculateCosts(tiles = tiles, dir = dir,
m = 70, v_max = 1.5, BMR = 76, k = 3.5, s = 0.05, l_s = 1,
L = 0.8)

# Generate five random points that fall within the region
points <- data.table(ID = 1:5,
                     x = runif(5, ext(region)[1], ext(region)[2]),
                     y = runif(5, ext(region)[3], ext(region)[4]))
                     
                     
# Calculate the path from 1 -> 2 -> 5 -> 1 -> 4 
pathOrder <- c(1,2,5,1,4)

# Make a world but limit it to the DEM grid size
defineWorld(source = grid, cut_slope = 0.5, 
            res = res(dem), dir = dir, overwrite=TRUE)
            
paths <- getPaths(region = region, nodes = points, order = pathOrder, 
                  costs = 'all', costFUN = energyCosts,
                       m = 70, v_max = 1.5, BMR = 76, k = 3.5, s = 0.05, l_s = 1,
                       L = 0.8)
                              
## Plot against corridors (not run)                         
#getCosts(region = region, from = points, proj = crs(dem), res = res(dem),
#                        destination = 'all', costs = 'all',
#                        output = 'file', dir = dir)                       
#corridors <- makeCorridor(rasters = dir, order = pathOrder)
#plot(corridors$time)
#plot(paths$time,add=TRUE)
}
